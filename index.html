<html>

    <head>
	<meta charset="utf-8">
	<style>
	 body { margin: 0 }
	 canvas { width: 100% height: 100% }
	</style>
    </head>

    <body>
	<script src="lib/three.js"></script>
	<script src="lib/tween.js"></script>
	<script src="lib/physi.js"></script>
	<script src="lib/ammo.js"></script>
	<script src="lib/threex.keyboardstate.js"></script>
	<script src="lib/threex.loop.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src="lib/PointerLockControls.js"></script>
	<script>

	 'use strict'

	 const shadowMapRes = 4096

	 const deg_to_rad = (deg) => deg * (Math.PI / 180)

	 Physijs.scripts.worker = "lib/physijs_worker.js"
	 Physijs.scripts.ammo = "ammo.js"

	 // SCENE
	 let scene = new Physijs.Scene
	 scene.setGravity(new THREE.Vector3(0,-30,0))
	 scene.background = new THREE.Color(0x3d8dcc)

	 // CAMERA
	 let camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 )

	 let camera_controls = new THREE.PointerLockControls(camera)

	 scene.add(camera_controls.getObject())

	 camera_controls.getObject().position.set(5,5,5)

	 let havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document


	 if (havePointerLock) {
	     console.log("can pointer lock")

	     let element = document.body;

	     const pointerlockchange = function ( event ) {

		 if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

		     camera_controls.enabled = true;

		 } else {

		     camera_controls.enabled = false;
		 }

	    };

	     // Hook pointer lock state change events
	     document.addEventListener( 'pointerlockchange', pointerlockchange, false )
	     document.addEventListener( 'mozpointerlockchange', pointerlockchange, false )
	     document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false )

	     element.addEventListener( 'click', function ( event ) {

		 // Ask the browser to lock the pointer
		 element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
		 element.requestPointerLock();

	     }, false )

	 }

	 // RENDERER
	 let renderer = new THREE.WebGLRenderer()
	 renderer.setSize( window.innerWidth, window.innerHeight )
	 document.body.appendChild( renderer.domElement )

	 renderer.shadowMap.enabled = true
	 renderer.shadowMap.type = THREE.PCFSoftShadowMap
	 renderer.shadowMap.renderReverseSided = false

	 renderer.gammaInput = true
	 renderer.gammaOutput = true

	 // ------------------------- LOADER CODE --------------------
	 let texLoader = new THREE.TextureLoader()
	 let jloader = new THREE.JSONLoader()

	 const load_file = (model_f, tex_f) => {
	     return new Promise((resolve,reject) => {
		 jloader.load(model_f, (geometry, mats) => {
		     texLoader.load(tex_f, (texture) => {
			 let mesh = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial({map: texture, flatShading: true, shininess: 0, specular: 0x000, morphTargets: true, vertexColors: THREE.FaceColors }) )
			 resolve(mesh)
		     }, (progress) => {}, (error) => reject(error))
		 })
	     }, (prog) => {}, (err) => reject(err))
	 }

	 // LIGHTING
	 let light = new THREE.DirectionalLight(0x999999, 1, 100)
	 light.position.set(30,30,10)
	 light.target.position.set(0,0,0)

	 light.shadow.mapSize.width = shadowMapRes
	 light.shadow.mapSize.height = shadowMapRes
	 light.shadow.camera.left = -85
	 light.shadow.camera.right = 45
	 light.shadow.camera.top = 50
	 light.shadow.camera.bottom = -50
	 light.shadow.camera.near = 1
	 light.shadow.camera.far = 150
	 light.castShadow = true

	 let light_helper = new THREE.DirectionalLightHelper(light, 5)
	 scene.add(light_helper)

	 let shadow_helper = new THREE.CameraHelper(light.shadow.camera)
	 scene.add(shadow_helper)

	 // AMBIENT LIGHT
	 let ambient = new THREE.AmbientLight(0x555555)

	 scene.add(light)
	 scene.add(ambient)

	 // camera.position.set(5,5,5)

	 // scene.add(camera)
	 //
	 // :::::::::::::::::::::::::::::: LOAD OBJECTS :::::::::::::::::::::::::::::
	 //

	 let plane = new Physijs.PlaneMesh(new THREE.PlaneGeometry(100,100),
					   new THREE.MeshStandardMaterial({color: 0x2222aa }))
	 plane.receiveShadow = true
	 plane.rotation.set(deg_to_rad(270), 0,0)

	 scene.add(plane)

	 let box = new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshStandardMaterial({ color: 0x22aa22 }))

	 box.castShadow = true
	 box.position.set(0,5,0)
	 scene.add(box)


	 // ORBIT CONTROLS
	 /* let controls = new THREE.OrbitControls( camera, renderer.domElement )
	  */
	 // KEYBOARD
	 let keyboard = new THREEx.KeyboardState()

	 // ANIM LOOP
	 const animate = () => {
	     renderer.render(scene, camera)
	 }


	 // ::::::::::::::::: UPDATE LOOP ::::::::::::::::::

	 const update = () => {
	     scene.simulate()
	 }

	 //
	 // :::::::::::::: UTIL FUNCTIONS ::::::::::::::::::::
	 //

	 const draw_vec = (vec) => {
	     let arr = new THREE.ArrowHelper(vec.clone().normalize(),
					     new THREE.Vector3(0,0,0),
					     vec.length(),
					     0x00ff00)
	     scene.add(arr)
	 }

	 let animLoop = new THREEx.RenderingLoop()
	 let physLoop = new THREEx.PhysicsLoop(60)

	 animLoop.add(animate)
	 physLoop.add(update)

	 animLoop.start()
	 physLoop.start()


	</script>
    </body>

</html>
